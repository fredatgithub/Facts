<#@ template debug="false" hostspecific="false" language="C#" #>
<#
    var Arguments = new Func<int, string>
    (
        (index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "obj";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "arg" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Parameters = new Func<int, string>
    (
        (int index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "T obj";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "T" + subindex + " arg" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Types = new Func<int, string>
    (
        (int index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "T";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "T" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Type = new Func<int, int, string>
    (
        (int total, int index) =>
        {
            if (total != 0)
            {
                if (total == 1)
                {
                    return "T";
                }
                else 
                {
                    return "T" + index;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );
#>
// <auto-generated />

namespace Theraot.Facts
{
<#
    for (var index = 1; index <= 7; index++)
    {
            #>
    public abstract class BinaryFactCheck<<#=Types(index)#>, TTarget> : IFactCheck<<#=Types(index)#>, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<<#=Types(index)#>, TTarget> left, IFactCheck<<#=Types(index)#>, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<<#=Types(index)#>, TTarget> Left { get; private set; }
        public IFactCheck<<#=Types(index)#>, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<<#=Types(index)#>, TTarget> : BinaryFactCheck<<#=Types(index)#>, TTarget>
    {
        public EqualsFactCheck(IFactCheck<<#=Types(index)#>, TTarget> left, IFactCheck<<#=Types(index)#>, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<<#=Types(index)#>>
    {
        public Fact()
        {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
            Item<#=indice#> = new FactData<<#=Types(index)#>, <#=Type(index, indice)#>>(this, 0);
<#
    }#>
        }

<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
        public FactData<<#=Types(index)#>, <#=Type(index, indice)#>> Item<#=indice#> { get; private set; }

<#
    }#>
        public void Add(<#=Parameters(index)#>)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<<#=Types(index)#>, TTarget> : IFactCheck<<#=Types(index)#>, TTarget>
    {
        internal FactData(Fact<<#=Types(index)#>> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<<#=Types(index)#>> Owner { get; private set; }

        public static IFactCheck<<#=Types(index)#>, TTarget> operator !=(FactData<<#=Types(index)#>, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<<#=Types(index)#>, TTarget>(left, right);
        }

        public static IFactCheck<<#=Types(index)#>, TTarget> operator !=(TTarget left, FactData<<#=Types(index)#>, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<<#=Types(index)#>, TTarget>(right, left);
        }

        public static IFactCheck<<#=Types(index)#>, TTarget> operator ==(FactData<<#=Types(index)#>, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(left, right);
        }

        public static IFactCheck<<#=Types(index)#>, TTarget> operator ==(TTarget left, FactData<<#=Types(index)#>, TTarget> right)
        {
            return new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<<#=Types(index)#>, TTarget> : BinaryFactCheck<<#=Types(index)#>, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<<#=Types(index)#>, TTarget> left, IFactCheck<<#=Types(index)#>, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<<#=Types(index)#>, TTarget> : IFactCheck<<#=Types(index)#>, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<<#=Types(index)#>, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<<#=Types(index)#>, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<<#=Types(index)#>, TTarget> : IFactCheck<<#=Types(index)#>, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<<#=Types(index)#>, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<<#=Types(index)#>, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
<#
    }#>
}