<#@ template debug="false" hostspecific="false" language="C#" #>
<#
    var Arguments = new Func<int, string>
    (
        (int index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "obj";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "arg" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Argument = new Func<int, int, string>
    (
        (int total, int index) =>
        {
            if (total != 0)
            {
                if (total == 1)
                {
                    return "obj";
                }
                else 
                {
                    return "arg" + index;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Parameters = new Func<int, string>
    (
        (int index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "T obj";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "T" + subindex + " arg" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Type = new Func<int, int, string>
    (
        (int total, int index) =>
        {
            if (total != 0)
            {
                if (total == 1)
                {
                    return "T";
                }
                else 
                {
                    return "T" + index;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );

    var Types = new Func<int, string>
    (
        (int index) =>
        {
            if (index != 0)
            {
                if (index == 1)
                {
                    return "T";
                }
                else 
                {
                    string result = string.Empty;
                    var first = true;
                    for(var subindex = 1; subindex <= index; subindex++)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else 
                        {
                            result += ", ";
                        }
                        result += "T" + subindex;
                    }
                    return result;
                }
            }
            else 
            {
                return string.Empty;
            }
        }
    );
#>
// <auto-generated />

using System;
using System.Collections.Generic;
using Theraot.Collections.Specialized;
using Theraot.Collections.ThreadSafe;

namespace Theraot.Facts
{<#
    for (var index = 1; index <= 7; index++)
    {
            #>

    public abstract class BinaryFactCheck<<#=Types(index)#>, TTarget> : FactCheck<<#=Types(index)#>, TTarget>
    {
        protected BinaryFactCheck(FactCheck<<#=Types(index)#>, TTarget> left, FactCheck<<#=Types(index)#>, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<<#=Types(index)#>, TTarget> Left { get; }

        public FactCheck<<#=Types(index)#>, TTarget> Right { get; }

        internal override Fact<<#=Types(index)#>> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<<#=Types(index)#>, TTarget> : BinaryFactCheck<<#=Types(index)#>, TTarget>
    {
        public EqualsFactCheck(FactCheck<<#=Types(index)#>, TTarget> left, FactCheck<<#=Types(index)#>, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<<#=Types(index)#>> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<<#=Types(index)#>>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<<#=Types(index)#>>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<<#=Types(index)#>>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<<#=Types(index)#>>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<<#=Types(index)#>>>>)
                    {
                        Predicate<Tuple<<#=Types(index)#>>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<<#=Types(index)#>, TTarget> : FactCheck<<#=Types(index)#>, TTarget>
    {
        public ComplementFactCheck(FactCheck<<#=Types(index)#>, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<<#=Types(index)#>, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<<#=Types(index)#>> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<<#=Types(index)#>>>;
            var result = new Dictionary<int, Predicate<Tuple<<#=Types(index)#>>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<<#=Types(index)#>> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<<#=Types(index)#>>
    {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
        private readonly IEqualityComparer<<#=Type(index, indice)#>> _comparer<#=indice#>;
<#
    }#>
        private readonly SafeSet<Tuple<<#=Types(index)#>>> _data;
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
        private readonly NullAwareDictionary<<#=Type(index, indice)#>, List<int>> _index<#=indice#>;
<#
    }#>
        private readonly TupleEqualityComparer<<#=Types(index)#>> _tupleComparer;

        public Fact()
        {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
            _comparer<#=indice#> = EqualityComparer<<#=Type(index, indice)#>>.Default;
<#
    }#>
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
            _index<#=indice#> = new NullAwareDictionary<<#=Type(index, indice)#>, List<int>>(_comparer<#=indice#>);
<#
    }#>
            _tupleComparer = TupleEqualityComparer<<#=Types(index)#>>.Default;
            _data = new SafeSet<Tuple<<#=Types(index)#>>>(_tupleComparer);
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
            Item<#=indice#> = new FactData<<#=Types(index)#>, <#=Type(index, indice)#>>(this, <#=indice#>);
<#
    }#>
        }

<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
        public FactData<<#=Types(index)#>, <#=Type(index, indice)#>> Item<#=indice#> { get; private set; }

<#
    }#>
        public void Add(<#=Parameters(index)#>)
        {
            var neo = new Tuple<<#=Types(index)#>>(<#=Arguments(index)#>);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                _index<#=indice#>.Add(<#=Argument(index, indice)#>, hash);
<#
    }#>
            }
        }

        public void Add(Tuple<<#=Types(index)#>> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                _index<#=indice#>.Add(tuple.Item<#=indice#>, hash);
<#
    }#>
            }
        }
        
        public void Remove(Tuple<<#=Types(index)#>> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                _index<#=indice#>.Remove(tuple.Item<#=indice#>, hash);
<#
    }#>
            }
        }

        public void Remove(int hash, Predicate<Tuple<<#=Types(index)#>>> predicate)
        {
            Tuple<<#=Types(index)#>> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                _index<#=indice#>.Remove(tuple.Item<#=indice#>, hash);
<#
    }#>
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<<#=Types(index)#>> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<<#=Types(index)#>> Read(int hash, Predicate<Tuple<<#=Types(index)#>>> predicate)
        {
            Tuple<<#=Types(index)#>> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<<#=Types(index)#>>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<<#=Types(index)#>>>>();
            Predicate<Tuple<<#=Types(index)#>>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<<#=Types(index)#>> tuple)
        {
            switch (itemIndex)
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                case <#=indice#>:
                    return _comparer<#=indice#>.Equals(tuple.Item<#=indice#>, (<#=Type(index, indice)#>)value);
<#
    }#>
            }
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<<#=Types(index)#>>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
<#
    for (var indice = 1; indice <= index; indice++)
    {
            #>
                case <#=indice#>:
                    predicate = tuple => _comparer<#=indice#>.Equals(tuple.Item<#=indice#>, (<#=Type(index, indice)#>)value);
                    if (_index<#=indice#>.TryGetValue((<#=Type(index, indice)#>)value, out result))
                    {
                        return result;
                    }
                    break;
<#
    }#>
            }
            predicate = input => false;
            return new int[0];
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<<#=Types(index)#>, TTarget> : FactCheck<<#=Types(index)#>, TTarget>
    {
        internal FactData(Fact<<#=Types(index)#>> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<<#=Types(index)#>> Owner { get; }

        public static FactCheck<<#=Types(index)#>, TTarget> operator !=(FactData<<#=Types(index)#>, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<<#=Types(index)#>, TTarget>(new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(left, right));
        }

        public static FactCheck<<#=Types(index)#>, TTarget> operator !=(TTarget left, FactData<<#=Types(index)#>, TTarget> right)
        {
            return new ComplementFactCheck<<#=Types(index)#>, TTarget>(new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(right, left));
        }

        public static FactCheck<<#=Types(index)#>, TTarget> operator ==(FactData<<#=Types(index)#>, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(left, right);
        }

        public static FactCheck<<#=Types(index)#>, TTarget> operator ==(TTarget left, FactData<<#=Types(index)#>, TTarget> right)
        {
            return new ValueEqualsFactCheck<<#=Types(index)#>, TTarget>(right, left);
        }

        internal override bool Check(Tuple<<#=Types(index)#>> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<<#=Types(index)#>> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<<#=Types(index)#>, TTarget> : FactCheck<<#=Types(index)#>, TTarget>
    {
        public ValueEqualsFactCheck(FactData<<#=Types(index)#>, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<<#=Types(index)#>, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<<#=Types(index)#>> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<<#=Types(index)#>> GetFact()
        {
            return Item.Owner;
        }
    }
<#
    }#>
}