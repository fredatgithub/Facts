// <auto-generated />

using System;
using System.Collections.Generic;
using System.Linq;
using Theraot.Collections.ThreadSafe;

namespace Theraot.Facts
{
    public abstract class FactCheckBase<T>
    {
        internal IEnumerable<Tuple<T>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T>>>, fact);
            }
            if (data is SafeSet<Tuple<T>>)
            {
                return data as SafeSet<Tuple<T>>;
            }
            return new Tuple<T>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T>>> data, Fact<T> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T> tuple);

        internal abstract object GetData();

        internal abstract Fact<T> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T, TTarget> : FactCheckBase<T>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2>
    {
        internal IEnumerable<Tuple<T1, T2>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2>>)
            {
                return data as SafeSet<Tuple<T1, T2>>;
            }
            return new Tuple<T1, T2>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2>>> data, Fact<T1, T2> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, TTarget> : FactCheckBase<T1, T2>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2, T3>
    {
        internal IEnumerable<Tuple<T1, T2, T3>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2, T3>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2, T3>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2, T3>>)
            {
                return data as SafeSet<Tuple<T1, T2, T3>>;
            }
            return new Tuple<T1, T2, T3>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2, T3>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2, T3>>> data, Fact<T1, T2, T3> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2, T3> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2, T3> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, T3, TTarget> : FactCheckBase<T1, T2, T3>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2, T3, T4>
    {
        internal IEnumerable<Tuple<T1, T2, T3, T4>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2, T3, T4>>)
            {
                return data as SafeSet<Tuple<T1, T2, T3, T4>>;
            }
            return new Tuple<T1, T2, T3, T4>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2, T3, T4>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>> data, Fact<T1, T2, T3, T4> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2, T3, T4> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2, T3, T4> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, T3, T4, TTarget> : FactCheckBase<T1, T2, T3, T4>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2, T3, T4, T5>
    {
        internal IEnumerable<Tuple<T1, T2, T3, T4, T5>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2, T3, T4, T5>>)
            {
                return data as SafeSet<Tuple<T1, T2, T3, T4, T5>>;
            }
            return new Tuple<T1, T2, T3, T4, T5>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2, T3, T4, T5>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>> data, Fact<T1, T2, T3, T4, T5> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2, T3, T4, T5> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2, T3, T4, T5> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, T3, T4, T5, TTarget> : FactCheckBase<T1, T2, T3, T4, T5>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2, T3, T4, T5, T6>
    {
        internal IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2, T3, T4, T5, T6>>)
            {
                return data as SafeSet<Tuple<T1, T2, T3, T4, T5, T6>>;
            }
            return new Tuple<T1, T2, T3, T4, T5, T6>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2, T3, T4, T5, T6>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>> data, Fact<T1, T2, T3, T4, T5, T6> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2, T3, T4, T5, T6> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2, T3, T4, T5, T6> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, T3, T4, T5, T6, TTarget> : FactCheckBase<T1, T2, T3, T4, T5, T6>
    {
        // Empty
    }

    public abstract class FactCheckBase<T1, T2, T3, T4, T5, T6, T7>
    {
        internal IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> GetTuples()
        {       
            var fact = GetFact();
            var data = GetData();
            if (data is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>)
            {
                return GetDataPrivate(data as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>, fact);
            }
            if (data is SafeSet<Tuple<T1, T2, T3, T4, T5, T6, T7>>)
            {
                return data as SafeSet<Tuple<T1, T2, T3, T4, T5, T6, T7>>;
            }
            return new Tuple<T1, T2, T3, T4, T5, T6, T7>[0]; // Fallback for wrong implementations
        }

        private static IEnumerable<Tuple<T1, T2, T3, T4, T5, T6, T7>> GetDataPrivate(IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>> data, Fact<T1, T2, T3, T4, T5, T6, T7> fact)
        {
            return from pair in data let hash = pair.Key let predicate = pair.Value select fact.Read(hash, predicate) into tuple where tuple != null select tuple;
        }

        internal abstract bool Check(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple);

        internal abstract object GetData();

        internal abstract Fact<T1, T2, T3, T4, T5, T6, T7> GetFact();
    }

    // ReSharper disable once UnusedTypeParameter
    public abstract class FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : FactCheckBase<T1, T2, T3, T4, T5, T6, T7>
    {
        // Empty
    }
}