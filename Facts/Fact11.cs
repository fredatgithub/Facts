// <auto-generated />

using System;
using System.Collections.Generic;
using Theraot.Collections.Specialized;
using Theraot.Collections.ThreadSafe;

namespace Theraot.Facts
{
    public abstract class BinaryFactCheck<T, TTarget> : FactCheck<T, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T, TTarget> left, FactCheck<T, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T, TTarget> Left { get; }

        public FactCheck<T, TTarget> Right { get; }

        internal override Fact<T> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T, TTarget> : BinaryFactCheck<T, TTarget>
    {
        public EqualsFactCheck(FactCheck<T, TTarget> left, FactCheck<T, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T>>>)
                    {
                        Predicate<Tuple<T>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T, TTarget> : FactCheck<T, TTarget>
    {
        public ComplementFactCheck(FactCheck<T, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T>>;
            var result = new Dictionary<int, Predicate<Tuple<T>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T>
    {
        private readonly IEqualityComparer<T> _comparer1;
        private readonly SafeSet<Tuple<T>> _data;
        private readonly NullAwareDictionary<T, List<int>> _index1;
        private readonly TupleEqualityComparer<T> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T>.Default;
            _index1 = new NullAwareDictionary<T, List<int>>(_comparer1);
            _tupleComparer = TupleEqualityComparer<T>.Default;
            _data = new SafeSet<Tuple<T>>(_tupleComparer);
            Item1 = new FactData<T, T>(this, 1);
        }

        public FactData<T, T> Item1 { get; private set; }

        public void Add(T obj)
        {
            var neo = new Tuple<T>(obj);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(obj, hash);
            }
        }

        public void Add(Tuple<T> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
            }
        }
        
        public void Remove(Tuple<T> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T> Read(int hash, Predicate<Tuple<T>> predicate)
        {
            Tuple<T> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T>>>();
            Predicate<Tuple<T>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T)value);
                    if (_index1.TryGetValue((T)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T>> predicate)
        {
            Tuple<T> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T, TTarget> : FactCheck<T, TTarget>
    {
        internal FactData(Fact<T> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T> Owner { get; }

        public static FactCheck<T, TTarget> operator !=(FactData<T, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T, TTarget>(new ValueEqualsFactCheck<T, TTarget>(left, right));
        }

        public static FactCheck<T, TTarget> operator !=(TTarget left, FactData<T, TTarget> right)
        {
            return new ComplementFactCheck<T, TTarget>(new ValueEqualsFactCheck<T, TTarget>(right, left));
        }

        public static FactCheck<T, TTarget> operator ==(FactData<T, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T, TTarget>(left, right);
        }

        public static FactCheck<T, TTarget> operator ==(TTarget left, FactData<T, TTarget> right)
        {
            return new ValueEqualsFactCheck<T, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T, TTarget> : FactCheck<T, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, TTarget> : FactCheck<T1, T2, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, TTarget> left, FactCheck<T1, T2, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, TTarget> Left { get; }

        public FactCheck<T1, T2, TTarget> Right { get; }

        internal override Fact<T1, T2> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, TTarget> : BinaryFactCheck<T1, T2, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, TTarget> left, FactCheck<T1, T2, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2>>>)
                    {
                        Predicate<Tuple<T1, T2>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, TTarget> : FactCheck<T1, T2, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly SafeSet<Tuple<T1, T2>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly TupleEqualityComparer<T1, T2> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _tupleComparer = TupleEqualityComparer<T1, T2>.Default;
            _data = new SafeSet<Tuple<T1, T2>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T1>(this, 1);
            Item2 = new FactData<T1, T2, T2>(this, 2);
        }

        public FactData<T1, T2, T1> Item1 { get; private set; }

        public FactData<T1, T2, T2> Item2 { get; private set; }

        public void Add(T1 arg1, T2 arg2)
        {
            var neo = new Tuple<T1, T2>(arg1, arg2);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
            }
        }

        public void Add(Tuple<T1, T2> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2> Read(int hash, Predicate<Tuple<T1, T2>> predicate)
        {
            Tuple<T1, T2> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2>>>();
            Predicate<Tuple<T1, T2>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2>> predicate)
        {
            Tuple<T1, T2> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, TTarget> : FactCheck<T1, T2, TTarget>
    {
        internal FactData(Fact<T1, T2> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2> Owner { get; }

        public static FactCheck<T1, T2, TTarget> operator !=(FactData<T1, T2, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, TTarget>(new ValueEqualsFactCheck<T1, T2, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, TTarget> operator !=(TTarget left, FactData<T1, T2, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, TTarget>(new ValueEqualsFactCheck<T1, T2, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, TTarget> operator ==(FactData<T1, T2, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, TTarget> operator ==(TTarget left, FactData<T1, T2, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, TTarget> : FactCheck<T1, T2, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, T3, TTarget> : FactCheck<T1, T2, T3, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, T3, TTarget> left, FactCheck<T1, T2, T3, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, T3, TTarget> Left { get; }

        public FactCheck<T1, T2, T3, TTarget> Right { get; }

        internal override Fact<T1, T2, T3> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, T3, TTarget> : BinaryFactCheck<T1, T2, T3, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, T3, TTarget> left, FactCheck<T1, T2, T3, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2, T3> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2, T3>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2, T3>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2, T3>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2, T3>>>)
                    {
                        Predicate<Tuple<T1, T2, T3>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, T3, TTarget> : FactCheck<T1, T2, T3, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, T3, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, T3, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2, T3> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2, T3>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2, T3> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2, T3>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly IEqualityComparer<T3> _comparer3;
        private readonly SafeSet<Tuple<T1, T2, T3>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly NullAwareDictionary<T3, List<int>> _index3;
        private readonly TupleEqualityComparer<T1, T2, T3> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _comparer3 = EqualityComparer<T3>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _index3 = new NullAwareDictionary<T3, List<int>>(_comparer3);
            _tupleComparer = TupleEqualityComparer<T1, T2, T3>.Default;
            _data = new SafeSet<Tuple<T1, T2, T3>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T3, T1>(this, 1);
            Item2 = new FactData<T1, T2, T3, T2>(this, 2);
            Item3 = new FactData<T1, T2, T3, T3>(this, 3);
        }

        public FactData<T1, T2, T3, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T3> Item3 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3)
        {
            var neo = new Tuple<T1, T2, T3>(arg1, arg2, arg3);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
                _index3.Add(arg3, hash);
            }
        }

        public void Add(Tuple<T1, T2, T3> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
                _index3.Add(tuple.Item3, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2, T3> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2, T3> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2, T3> Read(int hash, Predicate<Tuple<T1, T2, T3>> predicate)
        {
            Tuple<T1, T2, T3> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2, T3>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3>>>();
            Predicate<Tuple<T1, T2, T3>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2, T3> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
                case 3:
                    return _comparer3.Equals(tuple.Item3, (T3)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2, T3>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
                case 3:
                    predicate = tuple => _comparer3.Equals(tuple.Item3, (T3)value);
                    if (_index3.TryGetValue((T3)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2, T3>> predicate)
        {
            Tuple<T1, T2, T3> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, TTarget> : FactCheck<T1, T2, T3, TTarget>
    {
        internal FactData(Fact<T1, T2, T3> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2, T3> Owner { get; }

        public static FactCheck<T1, T2, T3, TTarget> operator !=(FactData<T1, T2, T3, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, T3, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, T3, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, T3, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, T3, TTarget> operator ==(FactData<T1, T2, T3, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, T3, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2, T3> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2, T3> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, T3, TTarget> : FactCheck<T1, T2, T3, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, T3, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, T3, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2, T3> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2, T3> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, T3, T4, TTarget> : FactCheck<T1, T2, T3, T4, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, T3, T4, TTarget> left, FactCheck<T1, T2, T3, T4, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, T3, T4, TTarget> Left { get; }

        public FactCheck<T1, T2, T3, T4, TTarget> Right { get; }

        internal override Fact<T1, T2, T3, T4> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, TTarget> : BinaryFactCheck<T1, T2, T3, T4, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, T3, T4, TTarget> left, FactCheck<T1, T2, T3, T4, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2, T3, T4> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>)
                    {
                        Predicate<Tuple<T1, T2, T3, T4>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, T3, T4, TTarget> : FactCheck<T1, T2, T3, T4, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, T3, T4, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, T3, T4, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2, T3, T4>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2, T3, T4> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2, T3, T4>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly IEqualityComparer<T3> _comparer3;
        private readonly IEqualityComparer<T4> _comparer4;
        private readonly SafeSet<Tuple<T1, T2, T3, T4>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly NullAwareDictionary<T3, List<int>> _index3;
        private readonly NullAwareDictionary<T4, List<int>> _index4;
        private readonly TupleEqualityComparer<T1, T2, T3, T4> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _comparer3 = EqualityComparer<T3>.Default;
            _comparer4 = EqualityComparer<T4>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _index3 = new NullAwareDictionary<T3, List<int>>(_comparer3);
            _index4 = new NullAwareDictionary<T4, List<int>>(_comparer4);
            _tupleComparer = TupleEqualityComparer<T1, T2, T3, T4>.Default;
            _data = new SafeSet<Tuple<T1, T2, T3, T4>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T3, T4, T1>(this, 1);
            Item2 = new FactData<T1, T2, T3, T4, T2>(this, 2);
            Item3 = new FactData<T1, T2, T3, T4, T3>(this, 3);
            Item4 = new FactData<T1, T2, T3, T4, T4>(this, 4);
        }

        public FactData<T1, T2, T3, T4, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T4> Item4 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var neo = new Tuple<T1, T2, T3, T4>(arg1, arg2, arg3, arg4);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
                _index3.Add(arg3, hash);
                _index4.Add(arg4, hash);
            }
        }

        public void Add(Tuple<T1, T2, T3, T4> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
                _index3.Add(tuple.Item3, hash);
                _index4.Add(tuple.Item4, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2, T3, T4> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2, T3, T4> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2, T3, T4> Read(int hash, Predicate<Tuple<T1, T2, T3, T4>> predicate)
        {
            Tuple<T1, T2, T3, T4> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2, T3, T4>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4>>>();
            Predicate<Tuple<T1, T2, T3, T4>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2, T3, T4> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
                case 3:
                    return _comparer3.Equals(tuple.Item3, (T3)value);
                case 4:
                    return _comparer4.Equals(tuple.Item4, (T4)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2, T3, T4>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
                case 3:
                    predicate = tuple => _comparer3.Equals(tuple.Item3, (T3)value);
                    if (_index3.TryGetValue((T3)value, out result))
                    {
                        return result;
                    }
                    break;
                case 4:
                    predicate = tuple => _comparer4.Equals(tuple.Item4, (T4)value);
                    if (_index4.TryGetValue((T4)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2, T3, T4>> predicate)
        {
            Tuple<T1, T2, T3, T4> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, TTarget> : FactCheck<T1, T2, T3, T4, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2, T3, T4> Owner { get; }

        public static FactCheck<T1, T2, T3, T4, TTarget> operator !=(FactData<T1, T2, T3, T4, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, T3, T4, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, T3, T4, TTarget> operator ==(FactData<T1, T2, T3, T4, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, T3, T4, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2, T3, T4> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2, T3, T4> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, T3, T4, TTarget> : FactCheck<T1, T2, T3, T4, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, T3, T4, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, T3, T4, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2, T3, T4> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, TTarget> : FactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, T3, T4, T5, TTarget> left, FactCheck<T1, T2, T3, T4, T5, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, T3, T4, T5, TTarget> Left { get; }

        public FactCheck<T1, T2, T3, T4, T5, TTarget> Right { get; }

        internal override Fact<T1, T2, T3, T4, T5> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, T3, T4, T5, TTarget> left, FactCheck<T1, T2, T3, T4, T5, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>)
                    {
                        Predicate<Tuple<T1, T2, T3, T4, T5>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, T3, T4, T5, TTarget> : FactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, T3, T4, T5, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, T3, T4, T5, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2, T3, T4, T5>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2, T3, T4, T5> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2, T3, T4, T5>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly IEqualityComparer<T3> _comparer3;
        private readonly IEqualityComparer<T4> _comparer4;
        private readonly IEqualityComparer<T5> _comparer5;
        private readonly SafeSet<Tuple<T1, T2, T3, T4, T5>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly NullAwareDictionary<T3, List<int>> _index3;
        private readonly NullAwareDictionary<T4, List<int>> _index4;
        private readonly NullAwareDictionary<T5, List<int>> _index5;
        private readonly TupleEqualityComparer<T1, T2, T3, T4, T5> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _comparer3 = EqualityComparer<T3>.Default;
            _comparer4 = EqualityComparer<T4>.Default;
            _comparer5 = EqualityComparer<T5>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _index3 = new NullAwareDictionary<T3, List<int>>(_comparer3);
            _index4 = new NullAwareDictionary<T4, List<int>>(_comparer4);
            _index5 = new NullAwareDictionary<T5, List<int>>(_comparer5);
            _tupleComparer = TupleEqualityComparer<T1, T2, T3, T4, T5>.Default;
            _data = new SafeSet<Tuple<T1, T2, T3, T4, T5>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T3, T4, T5, T1>(this, 1);
            Item2 = new FactData<T1, T2, T3, T4, T5, T2>(this, 2);
            Item3 = new FactData<T1, T2, T3, T4, T5, T3>(this, 3);
            Item4 = new FactData<T1, T2, T3, T4, T5, T4>(this, 4);
            Item5 = new FactData<T1, T2, T3, T4, T5, T5>(this, 5);
        }

        public FactData<T1, T2, T3, T4, T5, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T5> Item5 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            var neo = new Tuple<T1, T2, T3, T4, T5>(arg1, arg2, arg3, arg4, arg5);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
                _index3.Add(arg3, hash);
                _index4.Add(arg4, hash);
                _index5.Add(arg5, hash);
            }
        }

        public void Add(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
                _index3.Add(tuple.Item3, hash);
                _index4.Add(tuple.Item4, hash);
                _index5.Add(tuple.Item5, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2, T3, T4, T5> Read(int hash, Predicate<Tuple<T1, T2, T3, T4, T5>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5>>>();
            Predicate<Tuple<T1, T2, T3, T4, T5>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2, T3, T4, T5> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
                case 3:
                    return _comparer3.Equals(tuple.Item3, (T3)value);
                case 4:
                    return _comparer4.Equals(tuple.Item4, (T4)value);
                case 5:
                    return _comparer5.Equals(tuple.Item5, (T5)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2, T3, T4, T5>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
                case 3:
                    predicate = tuple => _comparer3.Equals(tuple.Item3, (T3)value);
                    if (_index3.TryGetValue((T3)value, out result))
                    {
                        return result;
                    }
                    break;
                case 4:
                    predicate = tuple => _comparer4.Equals(tuple.Item4, (T4)value);
                    if (_index4.TryGetValue((T4)value, out result))
                    {
                        return result;
                    }
                    break;
                case 5:
                    predicate = tuple => _comparer5.Equals(tuple.Item5, (T5)value);
                    if (_index5.TryGetValue((T5)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2, T3, T4, T5>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, TTarget> : FactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2, T3, T4, T5> Owner { get; }

        public static FactCheck<T1, T2, T3, T4, T5, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, T3, T4, T5, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, T3, T4, T5, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, T3, T4, T5, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2, T3, T4, T5> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : FactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, T3, T4, T5, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, T3, T4, T5, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2, T3, T4, T5> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, TTarget> left, FactCheck<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, T3, T4, T5, T6, TTarget> Left { get; }

        public FactCheck<T1, T2, T3, T4, T5, T6, TTarget> Right { get; }

        internal override Fact<T1, T2, T3, T4, T5, T6> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, TTarget> left, FactCheck<T1, T2, T3, T4, T5, T6, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>)
                    {
                        Predicate<Tuple<T1, T2, T3, T4, T5, T6>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, T3, T4, T5, T6, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2, T3, T4, T5, T6>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2, T3, T4, T5, T6> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2, T3, T4, T5, T6>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly IEqualityComparer<T3> _comparer3;
        private readonly IEqualityComparer<T4> _comparer4;
        private readonly IEqualityComparer<T5> _comparer5;
        private readonly IEqualityComparer<T6> _comparer6;
        private readonly SafeSet<Tuple<T1, T2, T3, T4, T5, T6>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly NullAwareDictionary<T3, List<int>> _index3;
        private readonly NullAwareDictionary<T4, List<int>> _index4;
        private readonly NullAwareDictionary<T5, List<int>> _index5;
        private readonly NullAwareDictionary<T6, List<int>> _index6;
        private readonly TupleEqualityComparer<T1, T2, T3, T4, T5, T6> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _comparer3 = EqualityComparer<T3>.Default;
            _comparer4 = EqualityComparer<T4>.Default;
            _comparer5 = EqualityComparer<T5>.Default;
            _comparer6 = EqualityComparer<T6>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _index3 = new NullAwareDictionary<T3, List<int>>(_comparer3);
            _index4 = new NullAwareDictionary<T4, List<int>>(_comparer4);
            _index5 = new NullAwareDictionary<T5, List<int>>(_comparer5);
            _index6 = new NullAwareDictionary<T6, List<int>>(_comparer6);
            _tupleComparer = TupleEqualityComparer<T1, T2, T3, T4, T5, T6>.Default;
            _data = new SafeSet<Tuple<T1, T2, T3, T4, T5, T6>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T3, T4, T5, T6, T1>(this, 1);
            Item2 = new FactData<T1, T2, T3, T4, T5, T6, T2>(this, 2);
            Item3 = new FactData<T1, T2, T3, T4, T5, T6, T3>(this, 3);
            Item4 = new FactData<T1, T2, T3, T4, T5, T6, T4>(this, 4);
            Item5 = new FactData<T1, T2, T3, T4, T5, T6, T5>(this, 5);
            Item6 = new FactData<T1, T2, T3, T4, T5, T6, T6>(this, 6);
        }

        public FactData<T1, T2, T3, T4, T5, T6, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T5> Item5 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T6> Item6 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            var neo = new Tuple<T1, T2, T3, T4, T5, T6>(arg1, arg2, arg3, arg4, arg5, arg6);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
                _index3.Add(arg3, hash);
                _index4.Add(arg4, hash);
                _index5.Add(arg5, hash);
                _index6.Add(arg6, hash);
            }
        }

        public void Add(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
                _index3.Add(tuple.Item3, hash);
                _index4.Add(tuple.Item4, hash);
                _index5.Add(tuple.Item5, hash);
                _index6.Add(tuple.Item6, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
                _index6.Remove(tuple.Item6, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2, T3, T4, T5, T6> Read(int hash, Predicate<Tuple<T1, T2, T3, T4, T5, T6>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5, T6> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6>>>();
            Predicate<Tuple<T1, T2, T3, T4, T5, T6>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
                case 3:
                    return _comparer3.Equals(tuple.Item3, (T3)value);
                case 4:
                    return _comparer4.Equals(tuple.Item4, (T4)value);
                case 5:
                    return _comparer5.Equals(tuple.Item5, (T5)value);
                case 6:
                    return _comparer6.Equals(tuple.Item6, (T6)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2, T3, T4, T5, T6>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
                case 3:
                    predicate = tuple => _comparer3.Equals(tuple.Item3, (T3)value);
                    if (_index3.TryGetValue((T3)value, out result))
                    {
                        return result;
                    }
                    break;
                case 4:
                    predicate = tuple => _comparer4.Equals(tuple.Item4, (T4)value);
                    if (_index4.TryGetValue((T4)value, out result))
                    {
                        return result;
                    }
                    break;
                case 5:
                    predicate = tuple => _comparer5.Equals(tuple.Item5, (T5)value);
                    if (_index5.TryGetValue((T5)value, out result))
                    {
                        return result;
                    }
                    break;
                case 6:
                    predicate = tuple => _comparer6.Equals(tuple.Item6, (T6)value);
                    if (_index6.TryGetValue((T6)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2, T3, T4, T5, T6>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5, T6> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
                _index6.Remove(tuple.Item6, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, T6, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5, T6> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2, T3, T4, T5, T6> Owner { get; }

        public static FactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, T6, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, T6, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2, T3, T4, T5, T6> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, T3, T4, T5, T6, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, T3, T4, T5, T6, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2, T3, T4, T5, T6> GetFact()
        {
            return Item.Owner;
        }
    }

    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        protected BinaryFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> left, FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Left { get; }

        public FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Right { get; }

        internal override Fact<T1, T2, T3, T4, T5, T6, T7> GetFact()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            if (leftFact != rightFact)
            {
                return null;
            }
            return leftFact;
        }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public EqualsFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> left, FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
            : base(left, right)
        {
            // Empty
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            return Left.Check(tuple) && Right.Check(tuple);
        }

        internal override object GetData()
        {
            var leftFact = Left.GetFact();
            var rightFact = Right.GetFact();
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>();
            if (leftFact != rightFact)
            {
                return result;
            }
            var leftData = Left.GetData();
            var rightData = Right.GetData();
            if (leftData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>)
            {
                if (rightData is IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>)
                {
                    var right = rightData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>;
                    foreach(var pair in leftData as IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>)
                    {
                        Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>> predicate;
                        if (right.TryGetValue(pair.Key, out predicate))
                        {
                            result.Add(pair.Key, input => predicate(input) && pair.Value(input));
                        }
                    }
                    return result;
                }
                return leftData;
            }
            return rightData;
        }
    }

    public class ComplementFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public ComplementFactCheck(FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> factCheck)
        {
            FactCheck = factCheck;
        }

        public FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> FactCheck { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            return !FactCheck.Check(tuple);
        }

        internal override object GetData()
        {
            var fact = FactCheck.GetFact();
            var all = fact.All() as SafeSet<Tuple<T1, T2, T3, T4, T5, T6, T7>>;
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>();
            if (all != null)
            {
                foreach (var tuple in all)
                {
                    if (Check(tuple))
                    {
                        result.Add(fact.Hash(tuple), Check);
                    }
                }
            }
            return result;
        }

        internal override Fact<T1, T2, T3, T4, T5, T6, T7> GetFact()
        {
            return FactCheck.GetFact();
        }
    }

    public class Fact<T1, T2, T3, T4, T5, T6, T7>
    {
        private readonly IEqualityComparer<T1> _comparer1;
        private readonly IEqualityComparer<T2> _comparer2;
        private readonly IEqualityComparer<T3> _comparer3;
        private readonly IEqualityComparer<T4> _comparer4;
        private readonly IEqualityComparer<T5> _comparer5;
        private readonly IEqualityComparer<T6> _comparer6;
        private readonly IEqualityComparer<T7> _comparer7;
        private readonly SafeSet<Tuple<T1, T2, T3, T4, T5, T6, T7>> _data;
        private readonly NullAwareDictionary<T1, List<int>> _index1;
        private readonly NullAwareDictionary<T2, List<int>> _index2;
        private readonly NullAwareDictionary<T3, List<int>> _index3;
        private readonly NullAwareDictionary<T4, List<int>> _index4;
        private readonly NullAwareDictionary<T5, List<int>> _index5;
        private readonly NullAwareDictionary<T6, List<int>> _index6;
        private readonly NullAwareDictionary<T7, List<int>> _index7;
        private readonly TupleEqualityComparer<T1, T2, T3, T4, T5, T6, T7> _tupleComparer;

        public Fact()
        {
            _comparer1 = EqualityComparer<T1>.Default;
            _comparer2 = EqualityComparer<T2>.Default;
            _comparer3 = EqualityComparer<T3>.Default;
            _comparer4 = EqualityComparer<T4>.Default;
            _comparer5 = EqualityComparer<T5>.Default;
            _comparer6 = EqualityComparer<T6>.Default;
            _comparer7 = EqualityComparer<T7>.Default;
            _index1 = new NullAwareDictionary<T1, List<int>>(_comparer1);
            _index2 = new NullAwareDictionary<T2, List<int>>(_comparer2);
            _index3 = new NullAwareDictionary<T3, List<int>>(_comparer3);
            _index4 = new NullAwareDictionary<T4, List<int>>(_comparer4);
            _index5 = new NullAwareDictionary<T5, List<int>>(_comparer5);
            _index6 = new NullAwareDictionary<T6, List<int>>(_comparer6);
            _index7 = new NullAwareDictionary<T7, List<int>>(_comparer7);
            _tupleComparer = TupleEqualityComparer<T1, T2, T3, T4, T5, T6, T7>.Default;
            _data = new SafeSet<Tuple<T1, T2, T3, T4, T5, T6, T7>>(_tupleComparer);
            Item1 = new FactData<T1, T2, T3, T4, T5, T6, T7, T1>(this, 1);
            Item2 = new FactData<T1, T2, T3, T4, T5, T6, T7, T2>(this, 2);
            Item3 = new FactData<T1, T2, T3, T4, T5, T6, T7, T3>(this, 3);
            Item4 = new FactData<T1, T2, T3, T4, T5, T6, T7, T4>(this, 4);
            Item5 = new FactData<T1, T2, T3, T4, T5, T6, T7, T5>(this, 5);
            Item6 = new FactData<T1, T2, T3, T4, T5, T6, T7, T6>(this, 6);
            Item7 = new FactData<T1, T2, T3, T4, T5, T6, T7, T7>(this, 7);
        }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T5> Item5 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T6> Item6 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T7> Item7 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            var neo = new Tuple<T1, T2, T3, T4, T5, T6, T7>(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            var hash = Hash(neo);
            if (_data.Add(neo))
            {
                _index1.Add(arg1, hash);
                _index2.Add(arg2, hash);
                _index3.Add(arg3, hash);
                _index4.Add(arg4, hash);
                _index5.Add(arg5, hash);
                _index6.Add(arg6, hash);
                _index7.Add(arg7, hash);
            }
        }

        public void Add(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            var hash = Hash(tuple);
            if (_data.Add(tuple))
            {
                _index1.Add(tuple.Item1, hash);
                _index2.Add(tuple.Item2, hash);
                _index3.Add(tuple.Item3, hash);
                _index4.Add(tuple.Item4, hash);
                _index5.Add(tuple.Item5, hash);
                _index6.Add(tuple.Item6, hash);
                _index7.Add(tuple.Item7, hash);
            }
        }
        
        public void Remove(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            var hash = _tupleComparer.GetHashCode(tuple);
            if (_data.Remove(tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
                _index6.Remove(tuple.Item6, hash);
                _index7.Remove(tuple.Item7, hash);
            }
        }

        internal object All()
        {
            return _data;
        }

        internal int Hash(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            return _tupleComparer.GetHashCode(tuple);
        }

        internal Tuple<T1, T2, T3, T4, T5, T6, T7> Read(int hash, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5, T6, T7> result;
            if (_data.TryGetValue(hash, predicate, out result))
            {
                return result;
            }
            return null;
        }

        internal IDictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>> Read(int itemIndex, object value)
        {
            var result = new Dictionary<int, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>>>();
            Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>> predicate;
            foreach (int hash in ReadPrivate(itemIndex, value, out predicate))
            {
                result.Add(hash, predicate);
            }
            // Should not be needed
            return result;
        }

        internal bool Check(int itemIndex, object value, Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            switch (itemIndex)
            {
                case 1:
                    return _comparer1.Equals(tuple.Item1, (T1)value);
                case 2:
                    return _comparer2.Equals(tuple.Item2, (T2)value);
                case 3:
                    return _comparer3.Equals(tuple.Item3, (T3)value);
                case 4:
                    return _comparer4.Equals(tuple.Item4, (T4)value);
                case 5:
                    return _comparer5.Equals(tuple.Item5, (T5)value);
                case 6:
                    return _comparer6.Equals(tuple.Item6, (T6)value);
                case 7:
                    return _comparer7.Equals(tuple.Item7, (T7)value);
            }
            // Should not be needed
            return false;
        }

        private IEnumerable<int> ReadPrivate(int itemIndex, object value, out Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>> predicate)
        {
            List<int> result;
            switch (itemIndex)
            {
                case 1:
                    predicate = tuple => _comparer1.Equals(tuple.Item1, (T1)value);
                    if (_index1.TryGetValue((T1)value, out result))
                    {
                        return result;
                    }
                    break;
                case 2:
                    predicate = tuple => _comparer2.Equals(tuple.Item2, (T2)value);
                    if (_index2.TryGetValue((T2)value, out result))
                    {
                        return result;
                    }
                    break;
                case 3:
                    predicate = tuple => _comparer3.Equals(tuple.Item3, (T3)value);
                    if (_index3.TryGetValue((T3)value, out result))
                    {
                        return result;
                    }
                    break;
                case 4:
                    predicate = tuple => _comparer4.Equals(tuple.Item4, (T4)value);
                    if (_index4.TryGetValue((T4)value, out result))
                    {
                        return result;
                    }
                    break;
                case 5:
                    predicate = tuple => _comparer5.Equals(tuple.Item5, (T5)value);
                    if (_index5.TryGetValue((T5)value, out result))
                    {
                        return result;
                    }
                    break;
                case 6:
                    predicate = tuple => _comparer6.Equals(tuple.Item6, (T6)value);
                    if (_index6.TryGetValue((T6)value, out result))
                    {
                        return result;
                    }
                    break;
                case 7:
                    predicate = tuple => _comparer7.Equals(tuple.Item7, (T7)value);
                    if (_index7.TryGetValue((T7)value, out result))
                    {
                        return result;
                    }
                    break;
            }
            // Empty result
            predicate = input => false;
            return new int[0];
        }

        internal void Remove(int hash, Predicate<Tuple<T1, T2, T3, T4, T5, T6, T7>> predicate)
        {
            Tuple<T1, T2, T3, T4, T5, T6, T7> tuple;
            if (_data.Remove(hash, predicate, out tuple))
            {
                _index1.Remove(tuple.Item1, hash);
                _index2.Remove(tuple.Item2, hash);
                _index3.Remove(tuple.Item3, hash);
                _index4.Remove(tuple.Item4, hash);
                _index5.Remove(tuple.Item5, hash);
                _index6.Remove(tuple.Item6, hash);
                _index7.Remove(tuple.Item7, hash);
            }
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5, T6, T7> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; }

        internal Fact<T1, T2, T3, T4, T5, T6, T7> Owner { get; }

        public static FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> left, TTarget right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(left, right));
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            return new ComplementFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(right, left));
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(left, right);
        }

        public static FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(right, left);
        }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            return true;
        }
        
        internal override object GetData()
        {
            return Owner.All();
        }

        internal override Fact<T1, T2, T3, T4, T5, T6, T7> GetFact()
        {
            return Owner;
        }
    }

#pragma warning restore 660, 661

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : FactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public ValueEqualsFactCheck(FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> Item { get; }

        public TTarget Value { get; }

        internal override bool Check(Tuple<T1, T2, T3, T4, T5, T6, T7> tuple)
        {
            return Item.Owner.Check(Item.ItemIndex, Value, tuple);
        }

        internal override object GetData()
        {
            return Item.Owner.Read(Item.ItemIndex, Value);
        }

        internal override Fact<T1, T2, T3, T4, T5, T6, T7> GetFact()
        {
            return Item.Owner;
        }
    }
}