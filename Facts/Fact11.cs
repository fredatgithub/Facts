// <auto-generated />

namespace Theraot.Facts
{
    public abstract class BinaryFactCheck<T, TTarget> : IFactCheck<T, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T, TTarget> left, IFactCheck<T, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T, TTarget> Left { get; private set; }
        public IFactCheck<T, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T, TTarget> : BinaryFactCheck<T, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T, TTarget> left, IFactCheck<T, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T>
    {
        public Fact()
        {
            Item1 = new FactData<T, T>(this, 0);
        }

        public FactData<T, T> Item1 { get; private set; }

        public void Add(T obj)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T, TTarget> : IFactCheck<T, TTarget>
    {
        internal FactData(Fact<T> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T> Owner { get; private set; }

        public static IFactCheck<T, TTarget> operator !=(FactData<T, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T, TTarget>(left, right);
        }

        public static IFactCheck<T, TTarget> operator !=(TTarget left, FactData<T, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T, TTarget>(right, left);
        }

        public static IFactCheck<T, TTarget> operator ==(FactData<T, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T, TTarget>(left, right);
        }

        public static IFactCheck<T, TTarget> operator ==(TTarget left, FactData<T, TTarget> right)
        {
            return new ValueEqualsFactCheck<T, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T, TTarget> : BinaryFactCheck<T, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T, TTarget> left, IFactCheck<T, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T, TTarget> : IFactCheck<T, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T, TTarget> : IFactCheck<T, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, TTarget> : IFactCheck<T1, T2, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, TTarget> left, IFactCheck<T1, T2, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, TTarget> : BinaryFactCheck<T1, T2, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, TTarget> left, IFactCheck<T1, T2, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T1>(this, 0);
            Item2 = new FactData<T1, T2, T2>(this, 0);
        }

        public FactData<T1, T2, T1> Item1 { get; private set; }

        public FactData<T1, T2, T2> Item2 { get; private set; }

        public void Add(T1 arg1, T2 arg2)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, TTarget> : IFactCheck<T1, T2, TTarget>
    {
        internal FactData(Fact<T1, T2> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2> Owner { get; private set; }

        public static IFactCheck<T1, T2, TTarget> operator !=(FactData<T1, T2, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, TTarget> operator !=(TTarget left, FactData<T1, T2, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, TTarget> operator ==(FactData<T1, T2, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, TTarget> operator ==(TTarget left, FactData<T1, T2, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, TTarget> : BinaryFactCheck<T1, T2, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, TTarget> left, IFactCheck<T1, T2, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, TTarget> : IFactCheck<T1, T2, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, TTarget> : IFactCheck<T1, T2, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, T3, TTarget> : IFactCheck<T1, T2, T3, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, T3, TTarget> left, IFactCheck<T1, T2, T3, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, T3, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, T3, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, T3, TTarget> : BinaryFactCheck<T1, T2, T3, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, T3, TTarget> left, IFactCheck<T1, T2, T3, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2, T3>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T3, T1>(this, 0);
            Item2 = new FactData<T1, T2, T3, T2>(this, 0);
            Item3 = new FactData<T1, T2, T3, T3>(this, 0);
        }

        public FactData<T1, T2, T3, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T3> Item3 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, TTarget> : IFactCheck<T1, T2, T3, TTarget>
    {
        internal FactData(Fact<T1, T2, T3> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2, T3> Owner { get; private set; }

        public static IFactCheck<T1, T2, T3, TTarget> operator !=(FactData<T1, T2, T3, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, T3, TTarget> operator ==(FactData<T1, T2, T3, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, T3, TTarget> : BinaryFactCheck<T1, T2, T3, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, T3, TTarget> left, IFactCheck<T1, T2, T3, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, T3, TTarget> : IFactCheck<T1, T2, T3, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, T3, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, T3, TTarget> : IFactCheck<T1, T2, T3, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, T3, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, T3, T4, TTarget> : IFactCheck<T1, T2, T3, T4, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, T3, T4, TTarget> left, IFactCheck<T1, T2, T3, T4, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, T3, T4, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, T3, T4, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, TTarget> : BinaryFactCheck<T1, T2, T3, T4, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, T3, T4, TTarget> left, IFactCheck<T1, T2, T3, T4, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2, T3, T4>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T3, T4, T1>(this, 0);
            Item2 = new FactData<T1, T2, T3, T4, T2>(this, 0);
            Item3 = new FactData<T1, T2, T3, T4, T3>(this, 0);
            Item4 = new FactData<T1, T2, T3, T4, T4>(this, 0);
        }

        public FactData<T1, T2, T3, T4, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T4> Item4 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, TTarget> : IFactCheck<T1, T2, T3, T4, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2, T3, T4> Owner { get; private set; }

        public static IFactCheck<T1, T2, T3, T4, TTarget> operator !=(FactData<T1, T2, T3, T4, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, T3, T4, TTarget> operator ==(FactData<T1, T2, T3, T4, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, T3, T4, TTarget> : BinaryFactCheck<T1, T2, T3, T4, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, TTarget> left, IFactCheck<T1, T2, T3, T4, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, T3, T4, TTarget> : IFactCheck<T1, T2, T3, T4, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, T3, T4, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, T3, T4, TTarget> : IFactCheck<T1, T2, T3, T4, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, TTarget> : IFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, T3, T4, T5, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, T3, T4, T5, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, T3, T4, T5, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2, T3, T4, T5>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T3, T4, T5, T1>(this, 0);
            Item2 = new FactData<T1, T2, T3, T4, T5, T2>(this, 0);
            Item3 = new FactData<T1, T2, T3, T4, T5, T3>(this, 0);
            Item4 = new FactData<T1, T2, T3, T4, T5, T4>(this, 0);
            Item5 = new FactData<T1, T2, T3, T4, T5, T5>(this, 0);
        }

        public FactData<T1, T2, T3, T4, T5, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T5> Item5 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, TTarget> : IFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2, T3, T4, T5> Owner { get; private set; }

        public static IFactCheck<T1, T2, T3, T4, T5, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : IFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, TTarget> : IFactCheck<T1, T2, T3, T4, T5, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2, T3, T4, T5, T6>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T3, T4, T5, T6, T1>(this, 0);
            Item2 = new FactData<T1, T2, T3, T4, T5, T6, T2>(this, 0);
            Item3 = new FactData<T1, T2, T3, T4, T5, T6, T3>(this, 0);
            Item4 = new FactData<T1, T2, T3, T4, T5, T6, T4>(this, 0);
            Item5 = new FactData<T1, T2, T3, T4, T5, T6, T5>(this, 0);
            Item6 = new FactData<T1, T2, T3, T4, T5, T6, T6>(this, 0);
        }

        public FactData<T1, T2, T3, T4, T5, T6, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T5> Item5 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T6> Item6 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, T6, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5, T6> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2, T3, T4, T5, T6> Owner { get; private set; }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, T6, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, T6, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, T6, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
    public abstract class BinaryFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        protected BinaryFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            Left = left;
            Right = right;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Left { get; private set; }
        public IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Right { get; private set; }
    }

    public class EqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public EqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class Fact<T1, T2, T3, T4, T5, T6, T7>
    {
        public Fact()
        {
            Item1 = new FactData<T1, T2, T3, T4, T5, T6, T7, T1>(this, 0);
            Item2 = new FactData<T1, T2, T3, T4, T5, T6, T7, T2>(this, 0);
            Item3 = new FactData<T1, T2, T3, T4, T5, T6, T7, T3>(this, 0);
            Item4 = new FactData<T1, T2, T3, T4, T5, T6, T7, T4>(this, 0);
            Item5 = new FactData<T1, T2, T3, T4, T5, T6, T7, T5>(this, 0);
            Item6 = new FactData<T1, T2, T3, T4, T5, T6, T7, T6>(this, 0);
            Item7 = new FactData<T1, T2, T3, T4, T5, T6, T7, T7>(this, 0);
        }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T1> Item1 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T2> Item2 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T3> Item3 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T4> Item4 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T5> Item5 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T6> Item6 { get; private set; }

        public FactData<T1, T2, T3, T4, T5, T6, T7, T7> Item7 { get; private set; }

        public void Add(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            throw new System.NotImplementedException();
        }
    }

#pragma warning disable 660,661 // Not meant to represent data

    public class FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        internal FactData(Fact<T1, T2, T3, T4, T5, T6, T7> owner, int itemIndex)
        {
            ItemIndex = itemIndex;
            Owner = owner;
        }

        internal int ItemIndex { get; private set; }

        internal Fact<T1, T2, T3, T4, T5, T6, T7> Owner { get; private set; }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator !=(FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> left, TTarget right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator !=(TTarget left, FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            return new ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(right, left);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator ==(FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> left, TTarget right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(left, right);
        }

        public static IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> operator ==(TTarget left, FactData<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        {
            return new ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>(right, left);
        }
    }

#pragma warning restore 660, 661

    public class NotEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : BinaryFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public NotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> left, IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> right)
        : base(left, right)
        {
        // Empty
        }
    }

    public class ValueEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public ValueEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }

    public class ValueNotEqualsFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> : IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget>
    {
        public ValueNotEqualsFactCheck(IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> item, TTarget value)
        {
            Item = item;
            Value = value;
        }

        public IFactCheck<T1, T2, T3, T4, T5, T6, T7, TTarget> Item { get; private set; }
        public TTarget Value { get; private set; }
    }
}